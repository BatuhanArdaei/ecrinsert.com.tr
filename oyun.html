<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Kapibara A≈ük Ko≈üusu üíñ</title>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
    
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: 'Fredoka', sans-serif;
      touch-action: none; /* T√ºm sayfa i√ßin kaydƒ±rmayƒ± kapat */
    }

    canvas { display: block; width: 100vw; height: 100vh; }

    #ui-layer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; display: flex; flex-direction: column; z-index: 10;
    }

    .nav-btn {
      position: absolute; top: 20px; left: 20px;
      background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(5px);
      padding: 10px 18px; border-radius: 30px; text-decoration: none;
      color: #555; font-weight: 600; font-size: 0.9rem;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1); pointer-events: auto; z-index: 20;
      display: flex; align-items: center; gap: 8px;
    }

    .score-box {
      position: absolute; top: 20px; right: 20px;
      background: rgba(255, 107, 129, 0.9); color: white;
      padding: 8px 20px; border-radius: 30px; font-size: 1.2rem; font-weight: 600;
      box-shadow: 0 4px 15px rgba(255, 107, 129, 0.4); text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }

    #menu-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(8px);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 30; pointer-events: auto; transition: opacity 0.3s;
    }

    .card {
      background: white; padding: 30px 40px; border-radius: 25px;
      text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      max-width: 90%; width: 350px;
      animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    h1 { color: #ff6b81; font-size: 2rem; margin-bottom: 10px; }
    p { color: #777; margin-bottom: 25px; font-size: 1rem; line-height: 1.5; }
    
    /* Butonun tƒ±klanabilirliƒüini artƒ±rdƒ±k */
    .btn-play {
      background: linear-gradient(45deg, #ff9a9e, #ff6b81); color: white; border: none;
      padding: 15px 40px; font-size: 1.2rem; border-radius: 50px; cursor: pointer;
      font-family: 'Fredoka', sans-serif; font-weight: 600;
      box-shadow: 0 10px 20px rgba(255, 107, 129, 0.3); transition: transform 0.2s;
      touch-action: manipulation; /* Dokunmatik iyile≈ütirmesi */
      pointer-events: auto; /* Tƒ±klamayƒ± garantiye al */
      position: relative; z-index: 50;
    }
    .btn-play:active { transform: scale(0.95); }

    .tutorial {
      margin-top: 20px; font-size: 0.85rem; color: #aaa;
      display: flex; align-items: center; justify-content: center; gap: 5px;
    }
  </style>
</head>
<body>

  <a href="../index.html" class="nav-btn"><i class="fa-solid fa-arrow-left"></i> Men√º</a>
  <canvas id="gameCanvas"></canvas>

  <div id="ui-layer">
    <div class="score-box">
      <i class="fa-solid fa-heart"></i> <span id="score-display">0</span>
    </div>
  </div>

  <div id="menu-overlay">
    <div class="card">
      <h1 id="menu-title">A≈ük Ko≈üusu üêæ</h1>
      <p id="menu-desc">Skor arttƒ±k√ßa hava kararacak!<br>Hazƒ±r mƒ±sƒ±n?</p>
      <!-- ID EKLENDƒ∞: start-btn -->
      <button id="start-btn" class="btn-play">BA≈ûLA</button>
      <div class="tutorial"><i class="fa-solid fa-hand-pointer"></i> Zƒ±plamak i√ßin dokun</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const menuOverlay = document.getElementById('menu-overlay');
    const menuTitle = document.getElementById('menu-title');
    const menuDesc = document.getElementById('menu-desc');
    const scoreDisplay = document.getElementById('score-display');
    const startButton = document.getElementById('start-btn'); // Butonu JS'e aldƒ±k

    let isPlaying = false;
    let score = 0;
    let gameSpeed = 6;
    let frame = 0;
    let W, H;

    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // === RENK GE√áƒ∞≈û FONKSƒ∞YONU ===
    function lerpColor(a, b, amount) {
        const ah = parseInt(a.replace(/#/g, ''), 16),
              ar = ah >> 16, ag = ah >> 8 & 0xff, ab = ah & 0xff,
              bh = parseInt(b.replace(/#/g, ''), 16),
              br = bh >> 16, bg = bh >> 8 & 0xff, bb = bh & 0xff,
              rr = ar + amount * (br - ar),
              rg = ag + amount * (bg - ag),
              rb = ab + amount * (bb - ab);
        return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb | 0).toString(16).slice(1);
    }

    // === OYUNCU ===
    const player = {
      x: 50, y: 0, w: 60, h: 40, dy: 0, jumpForce: 16, gravity: 0.55,
      grounded: false, jumpCount: 0, maxJumps: 2, color: '#c59a6b',
      draw: function() {
        ctx.save(); ctx.translate(this.x, this.y);
        let bob = this.grounded ? Math.sin(frame * 0.2) * 2 : 0;
        if (!this.grounded) ctx.rotate(-0.1);

        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.roundRect(0, 0 + bob, this.w, this.h, 15); ctx.fill();
        ctx.beginPath(); ctx.roundRect(this.w - 25, -15 + bob, 40, 40, 14); ctx.fill();
        ctx.fillStyle = '#3e2723'; ctx.beginPath(); ctx.arc(this.w + 5, -5 + bob, 4, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.w + 6, -7 + bob, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#8d6e63'; ctx.beginPath(); ctx.ellipse(this.w - 10, -15 + bob, 6, 8, 0.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#3e2723'; ctx.beginPath(); ctx.roundRect(this.w + 10, 2 + bob, 8, 6, 3); ctx.fill();
        ctx.fillStyle = 'rgba(255, 105, 180, 0.4)'; ctx.beginPath(); ctx.arc(this.w, 5 + bob, 6, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = '#8d6e63';
        if (this.grounded) {
            let legSwing = Math.sin(frame * 0.3) * 8;
            ctx.beginPath(); ctx.roundRect(10 + legSwing, this.h + bob - 5, 10, 12, 4); ctx.fill();
            ctx.beginPath(); ctx.roundRect(this.w - 20 - legSwing, this.h + bob - 5, 10, 12, 4); ctx.fill();
        } else {
            ctx.beginPath(); ctx.roundRect(5, this.h - 5, 10, 10, 4); ctx.fill();
            ctx.beginPath(); ctx.roundRect(this.w - 25, this.h - 8, 10, 10, 4); ctx.fill();
        }
        ctx.restore();
      },
      update: function() {
        this.dy += this.gravity; this.y += this.dy;
        let groundY = H - 100;
        if (this.y + this.h > groundY) {
            this.y = groundY - this.h; this.dy = 0; this.grounded = true; this.jumpCount = 0;
        } else { this.grounded = false; }
      },
      jump: function() {
        if (this.jumpCount < this.maxJumps) {
            this.dy = -this.jumpForce; this.jumpCount++; this.grounded = false;
            createParticles(this.x + this.w/2, this.y + this.h, 5, '#fff');
        }
      }
    };

    // === NESNELER ===
    let obstacles = [];
    let hearts = [];
    let particles = [];
    let stars = [];

    for(let i=0; i<60; i++) {
        stars.push({ x: Math.random()*window.innerWidth, y: Math.random()*(window.innerHeight/1.5), size: Math.random()*2.5, blink: Math.random() });
    }

    class Obstacle {
        constructor() {
            this.w = 40; this.h = 50 + Math.random() * 30;
            this.x = W; this.y = (H - 100) - this.h; this.color = '#66bb6a';
        }
        draw() {
            this.x -= gameSpeed;
            ctx.fillStyle = this.color; ctx.beginPath(); ctx.roundRect(this.x, this.y, this.w, this.h, 10); ctx.fill();
            ctx.strokeStyle = '#2e7d32'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(this.x + this.w/2, this.y + 5); ctx.lineTo(this.x + this.w/2, this.y + this.h - 5); ctx.stroke();
            ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(this.x + Math.random()*this.w, this.y + Math.random()*this.h, 3, 0, Math.PI*2); ctx.fill();
        }
    }

    class Heart {
        constructor() {
            this.size = 30; this.x = W; this.y = (H - 100) - 35 - Math.random() * 55; this.collected = false;
        }
        draw() {
            if(this.collected) return;
            this.x -= gameSpeed;
            let pulse = Math.sin(frame * 0.1) * 3;
            ctx.fillStyle = '#ff4757';
            let x = this.x, y = this.y, size = this.size + pulse;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.bezierCurveTo(x - size / 2, y - size / 2, x - size, y + size / 3, x, y + size);
            ctx.bezierCurveTo(x + size, y + size / 3, x + size / 2, y - size / 2, x, y);
            ctx.fill();
        }
    }

    function createParticles(x, y, count, color) {
        for(let i=0; i<count; i++) particles.push({ x: x, y: y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 1.0, color: color });
    }
    function updateParticles() {
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.03;
            ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1.0;
            if(p.life <= 0) particles.splice(i, 1);
        }
    }

    // === G√úN D√ñNG√úS√ú & √áƒ∞Zƒ∞M ===
    let bgOffset1 = 0, bgOffset2 = 0;
    const DayColors = { top: '#87CEEB', bot: '#E0F7FA', sun: '#FFD54F', hill: '#A5D6A7', ground: '#6D4C41' };
    const NightColors = { top: '#0d1b2a', bot: '#1b263b', sun: '#ffffff', hill: '#14213d', ground: '#221612' };

    function drawBackground() {
        // E≈ûƒ∞KLER (HIZLI GECE MODU): 10'da ba≈ülar, 100'de tam gece olur.
        let darkFactor = 0;
        if (score > 10) {
            darkFactor = (score - 10) / 90; 
            if(darkFactor > 1) darkFactor = 1;
        }

        let cTop = lerpColor(DayColors.top, NightColors.top, darkFactor);
        let cBot = lerpColor(DayColors.bot, NightColors.bot, darkFactor);
        let cSun = lerpColor(DayColors.sun, NightColors.sun, darkFactor);
        let cHill = lerpColor(DayColors.hill, NightColors.hill, darkFactor);
        let cGround = lerpColor(DayColors.ground, NightColors.ground, darkFactor);

        let grad = ctx.createLinearGradient(0, 0, 0, H);
        grad.addColorStop(0, cTop); grad.addColorStop(1, cBot);
        ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);

        if (darkFactor > 0.2) {
            ctx.fillStyle = '#fff';
            stars.forEach(s => {
                ctx.globalAlpha = darkFactor * (0.4 + Math.sin(frame * 0.1 + s.blink) * 0.6);
                ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
            });
            ctx.globalAlpha = 1.0;
        }

        let sunY = 50 + (darkFactor * 30);
        ctx.fillStyle = cSun;
        if(darkFactor > 0.8) { ctx.shadowBlur = 25; ctx.shadowColor = 'rgba(255,255,255,0.8)'; }
        ctx.beginPath(); ctx.arc(W - 50, sunY, 30, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;

        bgOffset1 -= (0.5 + darkFactor); if(bgOffset1 <= -W) bgOffset1 = 0;
        ctx.fillStyle = lerpColor('#90CAF9', '#2c3e50', darkFactor);
        for(let i=0; i<2; i++) {
            let startX = bgOffset1 + (i * W);
            ctx.beginPath(); ctx.moveTo(startX, H - 100); ctx.lineTo(startX + W/2, H - 300); ctx.lineTo(startX + W, H - 100); ctx.fill();
        }

        bgOffset2 -= (1.5 + darkFactor); if(bgOffset2 <= -W) bgOffset2 = 0;
        ctx.fillStyle = cHill;
        for(let i=0; i<2; i++) {
            let startX = bgOffset2 + (i * W);
            ctx.beginPath(); ctx.ellipse(startX + W/2, H - 80, W/1.5, 100, 0, Math.PI, 0); ctx.fill();
        }

        ctx.fillStyle = cGround; ctx.fillRect(0, H - 100, W, 100);
        ctx.fillStyle = lerpColor('#8D6E63', '#3b2721', darkFactor); ctx.fillRect(0, H - 100, W, 10);
    }

    function gameLoop() {
        if (!isPlaying) return;
        ctx.clearRect(0, 0, W, H);
        frame++;

        let targetSpeed = 6 + (score / 50);
        if(targetSpeed > 18) targetSpeed = 18;
        gameSpeed += (targetSpeed - gameSpeed) * 0.01;

        drawBackground();
        player.update(); player.draw();

        if (frame % Math.floor(100 - score/50) === 0 || (frame % 60 === 0 && Math.random() > 0.9)) { 
            if(Math.random() > 0.4) obstacles.push(new Obstacle());
        }
        if (frame % 80 === 0) { if(Math.random() > 0.5) hearts.push(new Heart()); }

        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i]; obs.draw();
            if (player.x < obs.x + obs.w - 10 && player.x + player.w > obs.x + 10 &&
                player.y < obs.y + obs.h - 10 && player.y + player.h > obs.y + 10) {
                gameOver();
            }
            if (obs.x + obs.w < 0) obstacles.splice(i, 1);
        }

        for (let i = hearts.length - 1; i >= 0; i--) {
            let heart = hearts[i]; heart.draw();
            let dx = (player.x + player.w/2) - heart.x;
            let dy = (player.y + player.h/2) - heart.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 80) { 
                hearts.splice(i, 1); score += 10; scoreDisplay.innerText = score;
                createParticles(heart.x, heart.y, 10, '#ff4757');
            }
            if (heart.x < -50) hearts.splice(i, 1);
        }
        updateParticles();
        requestAnimationFrame(gameLoop);
    }

    // === OYUNU BA≈ûLATMA (√ñNEMLƒ∞ D√úZELTME) ===
    function startGame() {
        console.log("Oyun ba≈ülƒ±yor...");
        isPlaying = true; score = 0; gameSpeed = 6; frame = 0;
        obstacles = []; hearts = []; particles = [];
        scoreDisplay.innerText = '0';
        player.y = H - 150; player.dy = 0; player.grounded = false;
        
        menuOverlay.style.opacity = '0'; 
        setTimeout(() => menuOverlay.style.display = 'none', 300);
        
        gameLoop();
    }

    // Buton Dinleyicisi (Hem click hem touchstart)
    if(startButton) {
        // Dokunmatik olayƒ±nƒ± durdurup sadece startGame'i √ßalƒ±≈ütƒ±rƒ±yoruz
        startButton.addEventListener('touchstart', (e) => {
            e.stopPropagation(); // Olayƒ±n window'a gitmesini engelle
            e.preventDefault();  // Varsayƒ±lan dokunma efektini engelle
            startGame();
        }, { passive: false });

        startButton.addEventListener('click', startGame);
    }

    function gameOver() {
        isPlaying = false;
        menuOverlay.style.display = 'flex'; setTimeout(() => menuOverlay.style.opacity = '1', 10);
        const title = document.getElementById('menu-title');
        const desc = document.getElementById('menu-desc');
        title.innerText = "Oyun Bitti! ü•∫"; desc.innerText = `Skorun: ${score}\nTekrar dene sevgilim!`;
        startButton.innerText = "TEKRAR OYNA";
    }

    // === GLOBAL KONTROLLER ===
    function handleJump(e) {
        // Eƒüer butonlara veya men√ºye dokunuluyorsa zƒ±plama yapma
        if(e.target.tagName === 'BUTTON' || e.target.closest('.nav-btn')) return;

        if(e.type === 'touchstart') e.preventDefault(); // Sayfa kaymasƒ±nƒ± engelle
        
        if (!isPlaying) { 
            // Oyun oynamƒ±yorsa hi√ßbir ≈üey yapma (Butonlar kendi listener'ƒ±na sahip)
            return; 
        } else { 
            player.jump(); 
        }
    }

    // Global dinleyiciler
    window.addEventListener('touchstart', handleJump, {passive: false});
    window.addEventListener('mousedown', handleJump);
    window.addEventListener('keydown', (e) => { if(e.code === 'Space') handleJump(e); });

    resize(); drawBackground(); player.y = H - 100 - player.h; player.draw();
  </script>
</body>
</html>